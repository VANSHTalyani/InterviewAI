"""
Video processor service for handling video processing and database operations
"""
import os
import asyncio
import subprocess
import json
from typing import Optional, List, Dict, Any
from datetime import datetime
from sqlalchemy.orm import Session
from pathlib import Path

from app.core.config import settings
from app.core.logging import logger
from app.models.schemas import VideoCreate, VideoResponse, VideoStatusEnum
from app.services.storage import storage_service

def get_abs_path(*parts):
    """Join and return an absolute path, handling slashes for all OSes."""
    return os.path.abspath(os.path.join(*parts))

# Update ffmpeg and ffprobe paths to the user's actual installation path
ffmpeg_path = r'C:\Users\swaya\AppData\Local\Programs\FFmpeg\bin\ffmpeg.exe'
ffprobe_path = r'C:\Users\swaya\AppData\Local\Programs\FFmpeg\bin\ffprobe.exe'

# For running commands
# ffmpeg._run.FFMPEG_BINARY = settings.FFMPEG_PATH
#ffmpeg._run.FFPROBE_BINARY = settings.FFMPEG_PATH.replace('ffmpeg', 'ffprobe')


# For probing metadata
# metadata = ffmpeg.probe('input.mp4', cmd=ffprobe_path)

class VideoProcessor:
    """
    Service for processing videos and managing video-related operations
    """
    
    def __init__(self):
        self.ffmpeg_path = ffmpeg_path
        self.ffprobe_path = ffprobe_path
    
    async def create_video_record(
        self,
        db: Session,
        video_data: VideoCreate,
        filename: str,
        file_size: int,
        mime_type: str
    ) -> int:
        """
        Create a video record in the database
        
        Args:
            db: Database session
            video_data: Video creation data
            filename: Stored filename
            file_size: File size in bytes
            mime_type: MIME type of the file
            
        Returns:
            Video ID
        """
        try:
            # This would interact with the actual database model
            # For now, we'll simulate it
            video_id = 1  # This would be generated by the database
            
            logger.info(f"Created video record: {video_id}")
            return video_id
            
        except Exception as e:
            logger.error(f"Failed to create video record: {e}")
            raise
    
    async def get_video_by_id(self, db: Session, video_id: int) -> Optional[VideoResponse]:
        """
        Get video information by ID
        
        Args:
            db: Database session
            video_id: Video ID
            
        Returns:
            Video information or None if not found
        """
        try:
            # This would query the actual database model
            # For now, we'll simulate it
            return VideoResponse(
                id=video_id,
                user_id="default_user",
                original_filename="test.mp4",
                filename="test.mp4",
                file_size=1000000,
                duration=60.0,
                mime_type="video/mp4",
                status=VideoStatusEnum.UPLOADED,
                created_at=datetime.utcnow()
            )
            
        except Exception as e:
            logger.error(f"Failed to get video by ID: {e}")
            return None
    
    async def delete_video(self, db: Session, video_id: int) -> bool:
        """
        Delete a video and its associated files
        
        Args:
            db: Database session
            video_id: Video ID
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Get video info first
            video = await self.get_video_by_id(db, video_id)
            if not video:
                return False
            
            # Delete file from storage
            await storage_service.delete_file(video.filename)
            
            # Delete associated audio and frame files
            await self._cleanup_processed_files(video.filename)
            
            # Delete from database
            # This would delete the actual database record
            
            logger.info(f"Deleted video: {video_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to delete video: {e}")
            return False
    
    async def process_video(self, video_id: int, file_url: str, filename: str):
        """
        Process a video file (extract audio, frames, get metadata)
        
        Args:
            video_id: Video ID
            file_url: URL or path to the video file
            filename: Filename of the video
        """
        try:
            logger.info(f"Starting video processing for {video_id}")
            
            # Get video duration and metadata
            metadata = await self._get_video_metadata(file_url)
            
            # Extract audio
            audio_path = await self._extract_audio(file_url, filename)
            
            # Extract frames
            frames_path = await self._extract_frames(file_url, filename)
            
            # Update video status in database
            await self._update_video_status(video_id, VideoStatusEnum.PROCESSING)
            
            logger.info(f"Video processing completed for {video_id}")
            
        except Exception as e:
            logger.error(f"Video processing failed for {video_id}: {e}")
            await self._update_video_status(video_id, VideoStatusEnum.FAILED)
    
    async def _get_video_metadata(self, file_path: str) -> Dict[str, Any]:
        """
        Get video metadata using ffprobe via subprocess
        """
        try:
            file_path = get_abs_path(file_path)
            if not os.path.exists(file_path):
                logger.error(f"File does not exist: {file_path}")
                raise FileNotFoundError(f"File does not exist: {file_path}")
            cmd = [
                ffprobe_path,
                '-v', 'error',
                '-select_streams', 'v:0',
                '-show_entries', 'stream=width,height,r_frame_rate,codec_name',
                '-show_entries', 'format=duration,bit_rate',
                '-of', 'json',
                file_path
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            probe = json.loads(result.stdout)
            video_stream = probe['streams'][0] if probe['streams'] else None
            if not video_stream:
                raise ValueError("No video stream found")
            metadata = {
                'duration': float(probe['format']['duration']),
                'width': int(video_stream['width']),
                'height': int(video_stream['height']),
                'fps': eval(video_stream['r_frame_rate']),
                'codec': video_stream['codec_name'],
                'bitrate': int(probe['format']['bit_rate']) if 'bit_rate' in probe['format'] else None
            }
            return metadata
        except Exception as e:
            logger.error(f"Failed to get video metadata: {e}")
            raise
    
    async def _extract_audio(self, video_path: str, filename: str) -> str:
        try:
            audio_filename = f"audio_{os.path.splitext(filename)[0]}.wav"
            audio_path = get_abs_path(settings.UPLOAD_DIR, "audio", audio_filename)
            video_path = get_abs_path(video_path)
            logger.info(f"Extracting audio from video: {video_path}")
            logger.info(f"Audio output path: {audio_path}")
            # Ensure output directory exists
            os.makedirs(os.path.dirname(audio_path), exist_ok=True)
            # Check input video existence
            if not os.path.exists(video_path):
                logger.error(f"Input video file does not exist: {video_path}")
                raise FileNotFoundError(f"Input video file does not exist: {video_path}")
            cmd = [
                ffmpeg_path,
                '-i', video_path,
                '-acodec', 'pcm_s16le',
                '-ar', str(settings.AUDIO_SAMPLE_RATE),
                '-ac', '1',
                audio_path,
                '-y'
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            logger.error(f"ffmpeg stdout: {result.stdout}")
            logger.error(f"ffmpeg stderr: {result.stderr}")
            if not os.path.exists(audio_path):
                logger.error(f"Audio file was not created: {audio_path}")
                raise FileNotFoundError(f"Audio file was not created: {audio_path}")
            logger.info(f"Audio extracted: {audio_path}")
            return audio_path
        except Exception as e:
            logger.error(f"Failed to extract audio: {e}")
            raise
    
    async def _extract_frames(self, video_path: str, filename: str) -> str:
        """
        Extract frames from video file at regular intervals using ffmpeg via subprocess
        """
        try:
            frames_dir = get_abs_path(settings.UPLOAD_DIR, "frames", os.path.splitext(filename)[0])
            Path(frames_dir).mkdir(parents=True, exist_ok=True)
            frame_pattern = get_abs_path(frames_dir, "frame_%04d.jpg")
            video_path = get_abs_path(video_path)
            fps = 1 / settings.FRAME_EXTRACTION_INTERVAL
            cmd = [
                ffmpeg_path,
                '-i', video_path,
                '-vf', f'fps={fps}',
                frame_pattern,
                '-y'
            ]
            subprocess.run(cmd, capture_output=True, text=True)
            logger.info(f"Frames extracted to: {frames_dir}")
            return frames_dir
        except Exception as e:
            logger.error(f"Failed to extract frames: {e}")
            raise
    
    async def _update_video_status(self, video_id: int, status: VideoStatusEnum):
        """
        Update video status in database
        
        Args:
            video_id: Video ID
            status: New status
        """
        try:
            # This would update the actual database record
            logger.info(f"Updated video {video_id} status to {status}")
            
        except Exception as e:
            logger.error(f"Failed to update video status: {e}")
    
    async def _cleanup_processed_files(self, filename: str):
        """
        Clean up processed files (audio, frames) for a video
        
        Args:
            filename: Original filename
        """
        try:
            base_name = os.path.splitext(filename)[0]
            
            # Clean up audio file
            audio_path = get_abs_path(settings.UPLOAD_DIR, "audio", f"audio_{base_name}.wav")
            if os.path.exists(audio_path):
                os.remove(audio_path)
            
            # Clean up frames directory
            frames_dir = get_abs_path(settings.UPLOAD_DIR, "frames", base_name)
            if os.path.exists(frames_dir):
                import shutil
                shutil.rmtree(frames_dir)
            
            logger.info(f"Cleaned up processed files for {filename}")
            
        except Exception as e:
            logger.error(f"Failed to cleanup processed files: {e}")
    
    async def get_video_audio_path(self, filename: str) -> Optional[str]:
        """
        Get the path to the extracted audio file
        
        Args:
            filename: Original filename
            
        Returns:
            Path to audio file or None if not found
        """
        base_name = os.path.splitext(filename)[0]
        audio_path = get_abs_path(settings.UPLOAD_DIR, "audio", f"audio_{base_name}.wav")
        
        if os.path.exists(audio_path):
            return audio_path
        return None
    
    async def get_video_frames_path(self, filename: str) -> Optional[str]:
        """
        Get the path to the extracted frames directory
        
        Args:
            filename: Original filename
            
        Returns:
            Path to frames directory or None if not found
        """
        base_name = os.path.splitext(filename)[0]
        frames_dir = get_abs_path(settings.UPLOAD_DIR, "frames", base_name)
        
        if os.path.exists(frames_dir):
            return frames_dir
        return None
    
    async def validate_video_file(self, file_path: str) -> Dict[str, Any]:
        """
        Validate a video file
        
        Args:
            file_path: Path to the video file
            
        Returns:
            Dictionary containing validation results
        """
        try:
            metadata = await self._get_video_metadata(file_path)
            
            validation_result = {
                'is_valid': True,
                'duration': metadata['duration'],
                'errors': [],
                'warnings': []
            }
            
            # Check duration
            if metadata['duration'] > settings.VIDEO_MAX_DURATION:
                validation_result['errors'].append(f"Video duration ({metadata['duration']}s) exceeds maximum ({settings.VIDEO_MAX_DURATION}s)")
                validation_result['is_valid'] = False
            
            # Check resolution
            if metadata['width'] < 320 or metadata['height'] < 240:
                validation_result['warnings'].append("Video resolution is very low")
            
            return validation_result
            
        except Exception as e:
            return {
                'is_valid': False,
                'duration': None,
                'errors': [f"Failed to validate video: {str(e)}"],
                'warnings': []
            }


# Global video processor instance
video_processor = VideoProcessor()
